This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
udp_video_client.py
udp_video_server.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="udp_video_client.py">
#!/usr/bin/env python3
"""
Pull UDP packets, rebuild frames, show video.
Default server filter 198.168.2.11, port 5005.
"""

import cv2
import socket
import struct
import numpy as np
import argparse
import time
from collections import defaultdict

PORT = 5004
TIMEOUT = 0.5        # seconds before tossing half‑baked frame

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--server', default='198.168.2.11',
                    help='accept packets only from this IP (use "any" to allow all)')
    ap.add_argument('--timeout', type=float, default=TIMEOUT)
    args = ap.parse_args()

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('', PORT))
    sock.settimeout(1.0)

    buffers = defaultdict(lambda: {'total': None, 'parts': {}, 'ts': time.time()})

    while True:
        try:
            packet, addr = sock.recvfrom(65_535)
        except socket.timeout:
            continue
        if args.server != 'any' and addr[0] != args.server:
            continue

        fid, total, idx = struct.unpack('!HHH', packet[:6])
        payload = packet[6:]

        buf = buffers[fid]
        buf['ts'] = time.time()
        if buf['total'] is None:
            buf['total'] = total
        buf['parts'][idx] = payload

        # got all chunks?
        if len(buf['parts']) == buf['total']:
            parts = [buf['parts'][i] for i in range(buf['total'])]
            jpg   = b''.join(parts)
            frame = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_COLOR)
            if frame is not None:
                cv2.imshow('UDP Stream', frame)
                if cv2.waitKey(1) == 27:   # ESC to quit
                    break
            del buffers[fid]

        # purge stale frames
        now = time.time()
        dead = [k for k, v in buffers.items() if now - v['ts'] > args.timeout]
        for k in dead:
            del buffers[k]

    sock.close()
    cv2.destroyAllWindows()

if __name__ == '__main__':
    main()
</file>

<file path="udp_video_server.py">
#!/usr/bin/env python3
"""
Fire webcam frames over UDP.
Default client IP 198.168.2.1, port 5005.
"""

import cv2
import socket
import struct
import argparse

CHUNK = 60_000                 # keep packets < 65 507 bytes
PORT  = 5005

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--client', default='198.168.2.1',
                    help='where to throw the packets')
    ap.add_argument('--source', type=int, default=0,
                    help='cv2.VideoCapture index')
    ap.add_argument('--quality', type=int, default=70,
                    help='JPEG quality (0‑100)')
    ap.add_argument('--chunk', type=int, default=CHUNK)
    args = ap.parse_args()

    cam  = cv2.VideoCapture(args.source)
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    enc_param = [cv2.IMWRITE_JPEG_QUALITY, args.quality]
    fid = 0

    while True:
        ok, frame = cam.read()
        if not ok:
            break

        ok, buf = cv2.imencode('.jpg', frame, enc_param)
        if not ok:
            continue

        data   = buf.tobytes()
        blocks = (len(data) - 1) // args.chunk + 1

        for idx in range(blocks):
            start = idx * args.chunk
            part  = data[start:start + args.chunk]
            header = struct.pack('!HHH', fid & 0xFFFF, blocks, idx)
            sock.sendto(header + part, (args.client, PORT))

        fid += 1

if __name__ == '__main__':
    main()
</file>

</files>
