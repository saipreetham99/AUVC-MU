This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cam.py
combine_client.py
imu.py
submarine_server.py
thrusters.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cam.py">
# File: cam.py
import cv2
import socket
import struct
import time
import threading
import logging

class CameraStreamer:
    """
    Captures video frames, encodes them as JPEG, splits them into chunks,
    and streams them over UDP to a specified client.
    """
    def __init__(self, client_ip, port, resolution=(640, 480), quality=70, fps=24):
        self.client_ip = client_ip
        self.port = port
        self.resolution = resolution
        self.quality = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
        self.max_packet_size = 60000  # Max size of a UDP packet payload

        self.running = False
        self._thread = None
        self._frame_id = 0
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        
        self.cap = cv2.VideoCapture(0)
        if not self.cap.isOpened():
            logging.error("Cannot open camera. Is it connected?")
            raise IOError("Cannot open camera")
            
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.resolution[0])
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.resolution[1])
        self.cap.set(cv2.CAP_PROP_FPS, fps)
        logging.info(f"Camera initialized at {self.resolution} @ {fps}fps, quality={quality}")

    def start(self):
        """Starts the video streaming thread."""
        if self.running:
            logging.warning("Camera streamer is already running.")
            return
        self.running = True
        self._thread = threading.Thread(target=self._stream_loop, daemon=True)
        self._thread.start()
        logging.info(f"Camera streaming started, sending to {self.client_ip}:{self.port}")

    def stop(self):
        """Stops the video streaming thread."""
        self.running = False
        if self._thread and self._thread.is_alive():
            self._thread.join()
        self.cap.release()
        self.sock.close()
        logging.info("Camera streaming stopped and resources released.")

    def _stream_loop(self):
        """The main loop for capturing and sending frames."""
        while self.running:
            try:
                ret, frame = self.cap.read()
                if not ret:
                    logging.warning("Failed to grab frame from camera.")
                    time.sleep(0.1)
                    continue

                # Encode the frame as JPEG
                result, encoded_frame = cv2.imencode('.jpg', frame, self.quality)
                if not result:
                    continue

                data = encoded_frame.tobytes()
                data_size = len(data)

                # Split data into chunks
                num_chunks = (data_size + self.max_packet_size - 1) // self.max_packet_size
                
                for i in range(num_chunks):
                    start = i * self.max_packet_size
                    end = start + self.max_packet_size
                    chunk = data[start:end]
                    
                    # Create header: Frame ID, Total Chunks, Chunk Index
                    header = struct.pack('!HHH', self._frame_id, num_chunks, i)
                    packet = header + chunk
                    
                    self.sock.sendto(packet, (self.client_ip, self.port))
                
                self._frame_id = (self._frame_id + 1) % 65535 # Wrap around to avoid overflow
                
                # Small sleep to yield CPU, actual FPS is limited by camera
                time.sleep(1/50) 

            except Exception as e:
                logging.error(f"Error in camera stream loop: {e}")
                # If a major error occurs, stop to prevent spamming logs
                if not self.cap.isOpened():
                    self.running = False
                    break
                time.sleep(1)
</file>

<file path="combine_client.py">
# File: combine_client.py
import pygame
import socket
import struct
import json
import cv2
import numpy as np
import threading
import time
import sys

# --- Configuration ---
SERVER_IP = '10.144.113.129'  # The IP of your Raspberry Pi submarine
CONTROL_PORT = 10000          # UDP port for sending commands
VIDEO_PORT = 10001            # UDP port for receiving video
IMU_PORT = 10002              # UDP port for receiving IMU data

# --- CONTROL CONSTANTS ---
NEUTRAL_PULSE = 1500
LIGHT_OFF, LIGHT_ON = 1100, 1900
DEAD = 0.6
LOOP_DURATION = 0.02 # 20ms, for a 50Hz loop rate

# --- CONTROLLER MAPPINGS ---
AXES = {
    "LEFT_STICK_X": 0, "LEFT_STICK_Y": 1,
    "RIGHT_STICK_X": 2, "RIGHT_STICK_Y": 3,
    "LT": 4, "RT": 5,
}

BUTTONS = {
    "A": 0, "B": 1, "X": 2, "Y": 3,
    "BACK": 4, "XBOX": 5, "START": 6,
    "LEFT_STICK_PRESS": 7, "RIGHT_STICK_PRESS": 8,
    "LB": 9, "RB": 10,
    "D_HAT_UP": 11, "D_HAT_DOWN": 12,
    "D_HAT_LEFT": 13, "D_HAT_RIGHT": 14,
    "MIDDLE": 15,
}

# Helper function
def clamp(x):
    return max(-1.0, min(1.0, x))

class SubmarineClient:
    def __init__(self):
        self.running = True
        self.latest_frame = None
        self.frame_lock = threading.Lock()
        self.latest_imu_data = None
        
        # --- UDP Control Socket ---
        self.server_address = (SERVER_IP, CONTROL_PORT)
        self.control_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # --- State Variables ---
        self.armed = False
        self.light_on = False
        self.lag_enabled = False # <<< NO-DELAY IS NOW DEFAULT
        self.AMP = 100
        self.AMP_STEP = 100
        self.AMP_MIN, self.AMP_MAX = 100, 400
        self.AMP_COOLDOWN = 0.25
        self.last_amp_time = 0

        # --- Initialize Pygame and Joystick ---
        pygame.init()
        pygame.joystick.init()
        if pygame.joystick.get_count() == 0:
            sys.exit("Error: No gamepad found.")
        self.pad = pygame.joystick.Joystick(0)
        self.pad.init()
        print(f"Gamepad found: {self.pad.get_name()}")
        
        self.screen = pygame.display.set_mode((640, 480))
        pygame.display.set_caption("Submarine Control")
        self.font = pygame.font.SysFont("monospace", 16)

    def _to_pwm(self, x):
        return int(NEUTRAL_PULSE + x * self.AMP)

    def _send_command(self, command_dict):
        """Encodes and sends a command dictionary over UDP."""
        try:
            payload = (json.dumps(command_dict) + '\n').encode('utf-8')
            self.control_socket.sendto(payload, self.server_address)
        except Exception as e:
            print(f"Error sending UDP command: {e}")

    # --- Video and IMU threads remain unchanged ---
    def _video_receiver_loop(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('', VIDEO_PORT)); buffers = {}
        while self.running:
            try:
                data, _ = sock.recvfrom(65536)
                if len(data) < 6: continue
                frame_id, num_chunks, chunk_id = struct.unpack('!HHH', data[:6])
                if frame_id not in buffers: buffers[frame_id] = {}
                buffers[frame_id][chunk_id] = data[6:]
                if len(buffers[frame_id]) == num_chunks:
                    full_jpeg = b''.join(chunk[1] for chunk in sorted(buffers[frame_id].items()))
                    frame = cv2.imdecode(np.frombuffer(full_jpeg, dtype=np.uint8), cv2.IMREAD_COLOR)
                    with self.frame_lock: self.latest_frame = frame
                    del buffers[frame_id]
                if frame_id % 100 == 0:
                    for f_id in list(buffers.keys()):
                        if f_id < frame_id - 10: del buffers[f_id]
            except Exception: pass
        sock.close()

    def _imu_receiver_loop(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.bind(('', IMU_PORT))
        while self.running:
            try:
                data, _ = sock.recvfrom(1024)
                self.latest_imu_data = json.loads(data.decode('utf-8'))
            except Exception: self.latest_imu_data = None
        sock.close()
        
    def _draw_hud(self):
        """Draws all status info, including the lag toggle state."""
        arm_text = self.font.render(f"ARMED: {self.armed}", True, (255, 0, 0) if self.armed else (0, 255, 0))
        self.screen.blit(arm_text, (10, 10))
        
        light_text = self.font.render(f"LIGHT: {'ON' if self.light_on else 'OFF'}", True, (255, 255, 0))
        self.screen.blit(light_text, (10, 30))

        amp_text = self.font.render(f"AMP: {self.AMP}", True, (255, 255, 255))
        self.screen.blit(amp_text, (10, 50))
        
        # <<<--- HUD BUTTON/STATUS FOR LAG TOGGLE --- >>>
        lag_status_text = "DELAY: OFF (MAX)" if not self.lag_enabled else "DELAY: ON (20ms)"
        lag_color = (255, 100, 0) if not self.lag_enabled else (0, 255, 255)
        lag_text = self.font.render(lag_status_text, True, lag_color)
        self.screen.blit(lag_text, (10, 70))
        
        if self.latest_imu_data:
            r = self.latest_imu_data['euler_deg']['roll']
            p = self.latest_imu_data['euler_deg']['pitch']
            y = self.latest_imu_data['euler_deg']['yaw']
            imu_text = self.font.render(f"R:{r:6.1f} P:{p:6.1f} Y:{y:6.1f}", True, (255, 255, 255))
            self.screen.blit(imu_text, (10, 90))

    def run(self):
        threading.Thread(target=self._video_receiver_loop, daemon=True).start()
        threading.Thread(target=self._imu_receiver_loop, daemon=True).start()
        clock = pygame.time.Clock()
        
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False; continue
                
                if event.type == pygame.JOYBUTTONDOWN:
                    if event.button == BUTTONS["START"]:
                        self.armed = not self.armed
                        print(f"\n[{'ARMED' if self.armed else 'SAFE'}]")
                        continue

                    # Lag Toggle Logic
                    elif event.button == BUTTONS["MIDDLE"]:
                        self.lag_enabled = not self.lag_enabled
                        status_text = "ENABLED (20ms)" if self.lag_enabled else "DISABLED (MAX SPEED)"
                        print(f"\n[CONTROL DELAY {status_text}]")

                    # D-Pad Controls
                    elif event.button == BUTTONS["D_HAT_RIGHT"]:
                        self.light_on = True; print("[LIGHT ON]")
                    elif event.button == BUTTONS["D_HAT_LEFT"]:
                        self.light_on = False; print("[LIGHT OFF]")
                    elif event.button == BUTTONS["D_HAT_UP"] and time.time() - self.last_amp_time > self.AMP_COOLDOWN:
                        self.AMP = min(self.AMP + self.AMP_STEP, self.AMP_MAX)
                        self.last_amp_time = time.time(); print("AMP", self.AMP)
                    elif event.button == BUTTONS["D_HAT_DOWN"] and time.time() - self.last_amp_time > self.AMP_COOLDOWN:
                        self.AMP = max(self.AMP - self.AMP_STEP, self.AMP_MIN)
                        self.last_amp_time = time.time(); print("AMP", self.AMP)

            # Axis, Deadzone, Bumper, and Safety logic is unchanged
            surge = -self.pad.get_axis(AXES["LEFT_STICK_Y"])
            strafe = self.pad.get_axis(AXES["LEFT_STICK_X"])
            heave = -self.pad.get_axis(AXES["RIGHT_STICK_Y"])
            yaw = self.pad.get_axis(AXES["RIGHT_STICK_X"])

            surge, strafe, heave, yaw = (0 if abs(v) < DEAD else v for v in [surge, strafe, heave, yaw])

            if self.pad.get_button(BUTTONS["RB"]) ^ self.pad.get_button(BUTTONS["LB"]):
                yaw = 1.0 if self.pad.get_button(BUTTONS["RB"]) else -1.0

            if not self.armed:
                surge = strafe = heave = yaw = 0

            if self.pad.get_button(BUTTONS["BACK"]):
                self.running = False; continue

            # Motor Mix & Command Packet
            t0 = self._to_pwm(clamp(surge - strafe - yaw))
            t1 = self._to_pwm(clamp(surge + strafe + yaw))
            t2 = self._to_pwm(clamp(surge + strafe - yaw))
            t3 = self._to_pwm(clamp(surge - strafe + yaw))
            t4 = self._to_pwm(clamp(heave))
            t5 = self._to_pwm(clamp(-heave))
            light_value = LIGHT_ON if self.light_on else LIGHT_OFF

            self._send_command({
                'command': 'control',
                'thruster_pulses': [t0, t1, t2, t3, t4, t5],
                'light_pulse': light_value, 
                'duration': LOOP_DURATION
            })

            # Drawing
            self.screen.fill((0, 0, 0))
            with self.frame_lock:
                if self.latest_frame is not None:
                    try:
                        frame_rgb = cv2.cvtColor(self.latest_frame, cv2.COLOR_BGR2RGB)
                        frame_pygame = pygame.surfarray.make_surface(np.rot90(frame_rgb))
                        self.screen.blit(frame_pygame, (0, 0))
                    except cv2.error: pass
            self._draw_hud()
            pygame.display.flip()
            
            # Conditional Loop Pacing
            if self.lag_enabled:
                clock.tick(1 / LOOP_DURATION)

        self.shutdown()

    def shutdown(self):
        print("Shutting down client...")
        self.running = False
        # Send one last neutral command for safety
        self._send_command({
            'command': 'control','thruster_pulses': [NEUTRAL_PULSE] * 6,
            'light_pulse': LIGHT_OFF, 'duration': 0
        })
        time.sleep(0.1) # Give it time to send
        self.control_socket.close()
        pygame.quit()

if __name__ == '__main__':
    client = SubmarineClient()
    try:
        client.run()
    except KeyboardInterrupt:
        client.shutdown()
</file>

<file path="imu.py">
# File: imu.py
# This is a refactored version of the provided mahony_filter_server.py
# It removes all networking and focuses on sensor fusion.
import numpy as np
import json
import time
import threading
import os
import logging
from dataclasses import dataclass
from typing import Optional

try:
    from scipy import linalg
except ImportError:
    logging.critical("SciPy is not installed (pip install scipy). IMU online calibration disabled.")
    linalg = None

# --- Helper Functions (copied from original) ---
def _normalize(v):
    norm = np.linalg.norm(v)
    return v / norm if norm > 1e-9 else v

def _q_multiply(q1, q2):
    w1, x1, y1, z1 = q1; w2, x2, y2, z2 = q2
    return np.array([w1*w2-x1*x2-y1*y2-z1*z2, w1*x2+x1*w2+y1*z2-z1*y2, w1*y2-x1*z2+y1*w2+z1*x2, w1*z2+x1*y2-y1*x2+z1*w2])

def _q_conjugate(q): return np.array([q[0], -q[1], -q[2], -q[3]])

def _q_to_dcm(q):
    q0,q1,q2,q3=q; return np.array([[q0**2+q1**2-q2**2-q3**2, 2*(q1*q2-q0*q3), 2*(q1*q3+q0*q2)],[2*(q1*q2+q0*q3), q0**2-q1**2+q2**2-q3**2, 2*(q2*q3-q0*q1)],[2*(q1*q3-q0*q2), 2*(q2*q3+q0*q1), q0**2-q1**2-q2**2+q3**2]])

def _get_q_from_acc(acc):
    acc_n = _normalize(acc); roll = np.arctan2(acc_n[1], np.sqrt(acc_n[0]**2 + acc_n[2]**2)); pitch = np.arctan2(-acc_n[0], np.sqrt(acc_n[1]**2 + acc_n[2]**2)); cy, sy = np.cos(0), np.sin(0); cp, sp = np.cos(pitch*0.5), np.sin(pitch*0.5); cr, sr = np.cos(roll*0.5), np.sin(roll*0.5); return np.array([cr*cp*cy+sr*sp*sy, sr*cp*cy-cr*sp*sy, cr*sp*cy+sr*cp*sy, cr*cp*sy-sr*sp*cy])

def _quaternion_to_euler(q):
    q0, q1, q2, q3 = q; roll = np.arctan2(2*(q0*q1+q2*q3), 1-2*(q1**2+q2**2)); sinp = 2*(q0*q2-q3*q1); pitch = np.arcsin(np.clip(sinp, -1, 1)); yaw = np.arctan2(2*(q0*q3+q1*q2), 1-2*(q2**2+q3**2)); return (np.degrees(roll), np.degrees(pitch), np.degrees(yaw))

# --- Mock Sensor Classes for Testing ---
class MockICM:
    def read_all(self):
        @dataclass
        class Accel: x: float; y: float; z: float
        @dataclass
        class Gyro: x: float; y: float; z: float
        @dataclass
        class MockData: a: Accel; g: Gyro
        return MockData(a=Accel(x=0, y=0, z=9.81), g=Gyro(x=np.degrees(0.01), y=np.degrees(-0.02), z=np.degrees(0.03)))

class MockMMC:
    def read_data(self):
        @dataclass
        class MockMagData: x: float; y: float; z: float
        return MockMagData(x=25.0, y=5.0, z=-30.0)

# --- Main IMU System Components ---
class MagnetometerCalibrator:
    def __init__(self, cache_path, collection_size=500, fit_interval=60.0):
        if not linalg: logging.warning("SciPy not found, MagnetometerCalibrator will not perform fitting.")
        self.cache_path = cache_path; self.collection_size = collection_size; self.fit_interval = fit_interval
        self.running = False; self.mag_points = []; self.hard_iron = np.zeros(3); self.soft_iron = np.eye(3)
        self.data_lock = threading.Lock(); self._load_from_cache()

    def add_point(self, mag_raw):
        with self.data_lock:
            if len(self.mag_points) < self.collection_size: self.mag_points.append(mag_raw)
            else: self.mag_points[np.random.randint(0, self.collection_size)] = mag_raw

    def correct(self, mag_raw): return self.soft_iron @ (mag_raw - self.hard_iron)

    def _fit_ellipsoid(self):
        if not linalg: return
        with self.data_lock:
            if len(self.mag_points) < 100: return
            points = np.array(self.mag_points)
            D = np.c_[points**2, 2*points[:,0]*points[:,1], 2*points[:,0]*points[:,2], 2*points[:,1]*points[:,2], 2*points]; v = np.ones(D.shape[0])
            try:
                # u = linalg.lstsq(D, v, rcond=None)[0] # This line does not work
                u = linalg.lstsq(D, v)[0]
                Q = np.array([[u[0],u[3],u[4]], [u[3],u[1],u[5]], [u[4],u[5],u[2]]]); b = np.array([u[6],u[7],u[8]])
                offset = -linalg.solve(Q, b); T = linalg.cholesky(Q); scale = T.T @ T
                if np.linalg.det(scale) < 1e-9: logging.warning("[MagCal] Unstable fit, skipping update."); return
                self.hard_iron = offset; self.soft_iron = scale
                logging.info(f"[MagCal] New calibration applied. Offset: {self.hard_iron}")
                self._save_to_cache()
            except linalg.LinAlgError: logging.warning("[MagCal] LinAlgError during fit. Skipping update.")

    def calibration_loop(self):
        self.running = True
        logging.info("[MagCal] Online magnetometer calibration running.")
        while self.running: time.sleep(self.fit_interval); self._fit_ellipsoid()

    def _load_from_cache(self):
        try:
            if os.path.exists(self.cache_path):
                with open(self.cache_path, 'r') as f: data = json.load(f)
                if 'hard_iron' in data and 'soft_iron' in data:
                    self.hard_iron = np.array(data['hard_iron']); self.soft_iron = np.array(data['soft_iron'])
                    logging.info(f"[MagCal] Loaded magnetometer calibration from {self.cache_path}")
        except Exception as e: logging.warning(f"Could not load mag cal from cache: {e}")

    def _save_to_cache(self):
        try:
            data = {}
            if os.path.exists(self.cache_path):
                with open(self.cache_path, 'r') as f: data = json.load(f)
            data['hard_iron'] = self.hard_iron.tolist(); data['soft_iron'] = self.soft_iron.tolist()
            with open(self.cache_path, 'w') as f: json.dump(data, f, indent=4)
        except Exception as e: logging.error(f"Could not save mag cal to cache: {e}")

    def stop(self): self.running = False; logging.info("[MagCal] Saving final calibration..."); self._fit_ellipsoid()

class AttitudeFilter:
    def __init__(self, frequency=100.0, kp=17.0, ki=0.2):
        self.q = np.array([1.0, 0.0, 0.0, 0.0]); self.bias = np.zeros(3); self.kp = kp; self.ki = ki; self.dt = 1.0 / frequency; self.gravity_ref = np.array([0.0, 0.0, 1.0])

    def update(self, gyr, acc, mag):
        acc_n, mag_n = _normalize(acc), _normalize(mag); dcm = _q_to_dcm(self.q); v_acc = dcm.T @ self.gravity_ref; error_acc = np.cross(acc_n, v_acc)
        mag_world_est = dcm @ mag_n; b_x = np.sqrt(mag_world_est[0]**2 + mag_world_est[1]**2); b_z = mag_world_est[2]; mag_ref_world = np.array([0.0, b_x, b_z])
        mag_ref_sensor_frame = dcm.T @ mag_ref_world; error_mag = np.cross(mag_n, mag_ref_sensor_frame); error = error_acc + error_mag
        self.bias += -self.ki * error * self.dt; omega = gyr - self.bias + self.kp * error; q_dot = 0.5 * _q_multiply(self.q, np.array([0.0, *omega]))
        self.q = _normalize(self.q + q_dot * self.dt); return self.q
    
    def set_initial_state(self, q0): self.q = np.copy(q0)

class IMUSystem:
    CACHE_FILENAME = "orientation_cache.json"

    def __init__(self, kp=17.0, ki=0.2, recalibrate_on_start=False):
        self.filter = AttitudeFilter(kp=kp, ki=ki)
        self.mag_calibrator = MagnetometerCalibrator(cache_path=self.CACHE_FILENAME)
        self.recalibrate = recalibrate_on_start
        self.reference_quaternion = np.array([1.0, 0.0, 0.0, 0.0])
        self.running = False
        self._threads = []
        self.latest_icm = None; self.latest_mmc = None
        self.latest_fused_data = None
        self.data_lock = threading.Lock(); self.reference_lock = threading.Lock()

        try: from icm20602 import ICM20602; self.icm = ICM20602(); logging.info("OK: ICM20602 sensor found.")
        except Exception: logging.warning("ICM20602 not found. Using mock sensor."); self.icm = MockICM()

        try: from mmc5983 import MMC5983; self.mmc = MMC5983(); logging.info("OK: MMC5983 sensor found.")
        except Exception: logging.warning("MMC5983 not found. Using mock sensor."); self.mmc = MockMMC()

    def start(self):
        self.running = True
        self._threads = [
            threading.Thread(target=self._read_icm_loop, daemon=True),
            threading.Thread(target=self._read_mmc_loop, daemon=True),
            threading.Thread(target=self.mag_calibrator.calibration_loop, daemon=True),
            threading.Thread(target=self._filter_loop, daemon=True)
        ]
        for t in self._threads: t.start()
        logging.info("IMU System started with all threads.")

    def stop(self):
        logging.info("Stopping IMU System...")
        self.running = False
        self.mag_calibrator.stop()
        for t in self._threads:
            if t.is_alive(): t.join(timeout=1.0)
        logging.info("IMU System stopped.")

    def reset_orientation(self):
        with self.reference_lock, self.data_lock:
            # Set the current *absolute* orientation as the new zero reference
            self.reference_quaternion = np.copy(self.filter.q)
        logging.info(f"Reference orientation tared. New zero is {self.reference_quaternion}")

    def get_latest_data(self) -> Optional[dict]:
        """Returns the most recent fused orientation data."""
        with self.data_lock:
            return self.latest_fused_data

    def _compute_relative_quaternion(self, q_current):
        with self.reference_lock:
            q_ref_inv = _q_conjugate(self.reference_quaternion)
            return _q_multiply(q_ref_inv, q_current)

    def _read_icm_loop(self):
        while self.running:
            try:
                d=self.icm.read_all(); ax,ay,az,gx,gy,gz=d.a.x,d.a.y,d.a.z,d.g.x,d.g.y,d.g.z
                with self.data_lock: self.latest_icm={'ax':ax,'ay':ay,'az':az,'gx':np.radians(gx),'gy':np.radians(gy),'gz':np.radians(gz)}
                time.sleep(0.01)
            except Exception as e: logging.error(f"ICM20602 read error: {e}"); time.sleep(1)

    def _read_mmc_loop(self):
        while self.running:
            try:
                d=self.mmc.read_data(); mx,my,mz=d.x,d.y,d.z; mag_raw = np.array([mx, my, mz])
                self.mag_calibrator.add_point(mag_raw)
                with self.data_lock: self.latest_mmc={'mx':mx,'my':my,'mz':mz}
                time.sleep(0.02)
            except Exception as e: logging.error(f"MMC5983 read error: {e}"); time.sleep(1)

    def _initialize_filter_state(self):
        q0 = None
        if not self.recalibrate:
            try:
                if os.path.exists(self.CACHE_FILENAME):
                    with open(self.CACHE_FILENAME, 'r') as f: data = json.load(f)
                    if 'q0' in data and len(data['q0']) == 4:
                        q0 = np.array(data['q0']); logging.info("Loaded initial orientation from cache.")
            except Exception as e: logging.warning(f"Could not load q0 from cache: {e}")
        
        if q0 is None:
            logging.info("No valid orientation in cache. Place device level to initialize (3s)...")
            time.sleep(3.0)
            acc_readings = []
            for _ in range(20):
                with self.data_lock:
                    if self.latest_icm: acc_readings.append([self.latest_icm['ax'], self.latest_icm['ay'], self.latest_icm['az']])
                time.sleep(0.1)
            if not acc_readings:
                logging.error("No accelerometer data for initialization. Using default."); q0 = np.array([1.0, 0, 0, 0])
            else:
                acc_avg = np.mean(acc_readings, axis=0); q0 = _get_q_from_acc(acc_avg)
                logging.info(f"Initialized with new orientation from accelerometer: {q0}")
            try:
                data = {}; 
                if os.path.exists(self.CACHE_FILENAME):
                    with open(self.CACHE_FILENAME, 'r') as f: data = json.load(f)
                data['q0'] = q0.tolist()
                with open(self.CACHE_FILENAME, 'w') as f: json.dump(data, f, indent=4)
            except Exception as e: logging.error(f"Could not save initial q0 to cache: {e}")
        
        self.filter.set_initial_state(q0)
        self.reset_orientation() # Set the initial reference to this q0

    def _filter_loop(self):
        logging.info("Filter loop waiting for sensor data..."); time.sleep(1)
        self._initialize_filter_state()
        logging.info("IMU initialization complete. Starting attitude estimation.")
        
        while self.running:
            with self.data_lock: icm_data=self.latest_icm; mmc_data=self.latest_mmc
            if icm_data and mmc_data:
                acc_raw=np.array([icm_data['ax'], icm_data['ay'], icm_data['az']]); gyr_raw=np.array([icm_data['gx'], icm_data['gy'], icm_data['gz']]); mag_raw=np.array([mmc_data['mx'], mmc_data['my'], mmc_data['mz']])
                mag_corrected = self.mag_calibrator.correct(mag_raw)
                q_absolute = self.filter.update(gyr_raw, acc_raw, mag_corrected)
                q_relative = self._compute_relative_quaternion(q_absolute)
                roll, pitch, yaw = _quaternion_to_euler(q_relative)

                with self.data_lock:
                    self.latest_fused_data = {
                        'timestamp': time.time(),
                        'quaternion': q_relative.tolist(),
                        'euler_deg': {'roll': roll, 'pitch': pitch, 'yaw': yaw}
                    }
            time.sleep(self.filter.dt)
</file>

<file path="submarine_server.py">
# File: submarine_server.py
import socket
import threading
import json
import time
import logging
import sys

# Import our refactored modules
import cam
import imu
import thrusters

# --- Configuration ---
HOST_IP = '0.0.0.0'         # Listen on all available network interfaces
# CLIENT_IP is no longer needed for sending, but kept for camera/imu
CLIENT_IP = '10.144.113.184'

CONTROL_PORT = 10000        # UDP port for receiving commands
VIDEO_PORT = 10001          # UDP port for streaming video
IMU_PORT = 10002            # UDP port for streaming IMU data

# Safety timeout in seconds. If no packet is received for this duration,
# thrusters will be set to neutral.
CONTROL_TIMEOUT = 0.5

# Setup basic logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)

class SubmarineServer:
    def __init__(self):
        self.running = True
        self.camera_system = None
        self.imu_system = None
        self.thruster_system = None
        
    def start(self):
        """Initializes and starts all subsystems."""
        try:
            logging.info("--- Initializing Camera ---")
            self.camera_system = cam.CameraStreamer(client_ip=CLIENT_IP, port=VIDEO_PORT)
            self.camera_system.start()

            logging.info("--- Initializing IMU ---")
            self.imu_system = imu.IMUSystem()
            self.imu_system.start()
            
            time.sleep(4) # Wait for IMU to get first reading

            logging.info("--- Initializing Thrusters ---")
            self.thruster_system = thrusters.ThrusterController()
            logging.info("--- All systems initialized. Server is ready. ---")

            # Start networking threads
            threading.Thread(target=self._udp_control_loop, daemon=True).start()
            threading.Thread(target=self._imu_streamer_loop, daemon=True).start()

        except Exception as e:
            logging.critical(f"Failed to initialize server: {e}", exc_info=True)
            self.shutdown()
            return
            
        while self.running:
            try:
                time.sleep(1)
            except KeyboardInterrupt:
                logging.info("Keyboard interrupt received.")
                self.shutdown()

    def shutdown(self):
        """Gracefully shuts down all subsystems."""
        if not self.running: return
        logging.info("--- Server shutting down... ---")
        self.running = False
        if self.camera_system: self.camera_system.stop()
        if self.imu_system: self.imu_system.stop()
        if self.thruster_system: self.thruster_system.safe_shutdown()
        logging.info("--- Shutdown complete. ---")

    def _imu_streamer_loop(self):
        """Streams IMU data over UDP."""
        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        logging.info(f"IMU data streamer started, sending to {CLIENT_IP}:{IMU_PORT}")
        while self.running:
            try:
                data = self.imu_system.get_latest_data()
                if data:
                    payload = json.dumps(data).encode('utf-8')
                    udp_socket.sendto(payload, (CLIENT_IP, IMU_PORT))
                time.sleep(1/50)
            except Exception as e:
                logging.error(f"Error in IMU streamer loop: {e}")
                time.sleep(1)
        udp_socket.close()

    def _udp_control_loop(self):
        """Listens for UDP command packets and handles them."""
        control_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        control_socket.bind((HOST_IP, CONTROL_PORT))
        control_socket.settimeout(CONTROL_TIMEOUT) # Set the safety timeout
        logging.info(f"Control server listening on UDP {HOST_IP}:{CONTROL_PORT}")

        while self.running:
            try:
                # Wait for a packet
                data, addr = control_socket.recvfrom(1024)
                
                # We expect a JSON string followed by a newline
                line = data.strip()
                if not line: continue

                msg = json.loads(line.decode('utf-8'))
                command = msg.get('command')

                if command == 'control':
                    # Log the received command for debugging
                    logging.info(f"Rx from {addr}: Thrusters: {msg['thruster_pulses']}, Light: {msg['light_pulse']}")
                    
                    self.thruster_system.apply_control(
                        msg['thruster_pulses'],
                        msg['light_pulse'],
                        0 # Duration is now handled client-side
                    )
                elif command == 'reset_orientation':
                    self.imu_system.reset_orientation()
                    logging.info(f"Rx from {addr}: Command to reset IMU orientation.")
                else:
                    logging.warning(f"Rx from {addr}: Unknown command '{command}'")

            except socket.timeout:
                # This is the safety feature. If no packet is received for the
                # duration of the timeout, set thrusters to neutral.
                logging.warning(f"CONTROL TIMEOUT: No packet received for {CONTROL_TIMEOUT}s. Setting thrusters to neutral.")
                self.thruster_system.set_neutral()
            except json.JSONDecodeError:
                logging.error("Received invalid JSON from client.")
            except Exception as e:
                if self.running:
                    logging.error(f"Error in UDP control loop: {e}", exc_info=True)

        control_socket.close()


if __name__ == '__main__':
    server = SubmarineServer()
    try:
        server.start()
    finally:
        server.shutdown()
</file>

<file path="thrusters.py">
# File: thrusters.py
import time
import logging

try:
    from pca9685 import PCA9685
except ImportError:
    logging.critical("Failed to import pca9685. Is the library installed? Using mock interface.")
    # Define a mock class that accurately reflects the real library's API
    class PCA9685:
        def __init__(self): 
            # The real library uses a .pwm attribute that can be assigned to.
            self.pwm = [0]*16
            logging.info("Mock PCA: Initialized.")
        def set_pwm_frequency(self, freq): 
            logging.info(f"Mock PCA: Freq set to {freq}Hz")
        def output_enable(self): 
            logging.info("Mock PCA: Output enabled.")
        def output_disable(self): 
            logging.info("Mock PCA: Output disabled.")

class ThrusterController:
    """
    Manages the PCA9685 board to control 6 thrusters and 1 light.
    Handles safe startup and shutdown procedures.
    THIS VERSION USES DIRECT PULSE WIDTH ASSIGNMENT.
    """
    NEUTRAL_PULSE = 1500
    LIGHT_OFF_PULSE = 1100
    THRUSTER_CHANNELS = range(6)
    LIGHT_CHANNEL = 9

    def __init__(self):
        logging.info("Initializing Thruster Controller (PCA9685)...")
        self.pca = PCA9685()
        self.pca.set_pwm_frequency(50)
        # Set all outputs to a known safe state on startup
        self.set_neutral()
        self.pca.output_enable()
        logging.info("Thruster ESCs initialized. Audible sound should occur now.")

    def set_neutral(self):
        """Sets all thrusters to neutral and turns off the light by directly assigning pulse values."""
        for ch in self.THRUSTER_CHANNELS:
            # Directly assign the pulse width value. This is the correct logic.
            self.pca.pwm[ch] = self.NEUTRAL_PULSE
            
        self.pca.pwm[self.LIGHT_CHANNEL] = self.LIGHT_OFF_PULSE
        time.sleep(0.05) # Allow time for commands to process

    def apply_control(self, thruster_pulses, light_pulse, duration):
        """
        Applies specified pulse values directly to the PCA9685 board's channels.

        Args:
            thruster_pulses (list[int]): A list of 6 integer pulse values (e.g., 1100-1900).
            light_pulse (int): The integer pulse value for the light.
            duration (float): The time in seconds to hold these values.
        """
        if len(thruster_pulses) != 6:
            logging.error(f"Invalid thruster pulse count: {len(thruster_pulses)}. Expected 6.")
            return

        # Assign each thruster pulse directly to its channel.
        for i, pulse in enumerate(thruster_pulses):
            self.pca.pwm[self.THRUSTER_CHANNELS[i]] = pulse
        
        # Assign the light pulse directly.
        self.pca.pwm[self.LIGHT_CHANNEL] = light_pulse

        # The client-server loop depends on this sleep to maintain the command rate.
        time.sleep(duration)
        
    def safe_shutdown(self):
        """Sets all outputs to a safe state and disables the PCA9685 driver."""
        logging.info("Executing safe thruster shutdown...")
        self.set_neutral()
        self.pca.output_disable()
        logging.info("Thruster shutdown complete.")
</file>

</files>
